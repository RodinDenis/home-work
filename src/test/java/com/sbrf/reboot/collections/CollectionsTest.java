package com.sbrf.reboot.collections;

import org.junit.jupiter.api.Test;
import org.mockito.internal.util.collections.Sets;

import java.util.*;

import static org.junit.jupiter.api.Assertions.assertEquals;

public class CollectionsTest {


    /*
     * Задача.
     * Имеется список лучших студентов вуза.
     *
     * 1. Иванов
     * 2. Петров
     * 3. Сидоров
     *
     * В новом семестре по результатам подсчетов оценок в рейтинг на 1 место добавился новый студент - Козлов.
     * Теперь в рейтинге участвуют 4 студента.
     * (Предполагаем что в рейтинг можно попасть только получив достаточное количество балов, что бы занять 1 место).
     *
     * Вопрос.
     * Какую коллекцию из Collections framework вы предпочтете для текущего хранения и использования списка студентов?
     *
     * Проинициализируйте students, добавьте в нее 4 фамилии студентов что бы тест завершился успешно.
     */
    @Test
    public void addStudentToRating() {
        /*
        * Проще всего использовать ArrayList для хранения рейтинга студентов.
        * Но по условию, чтобы попасть в рейтинг = нужно занять 1 место, тогда самым быстрым решением будет
        * добавить ссылку на новое 1 место, то есть для хранения использовать LinkedList хоть он и будет весить больше из-за наличия ссылок;
        *
        */

        List<String> students = new LinkedList<>(Arrays.asList("Иванов", "Петров", "Сидоров", "Козлов"));

        assertEquals(4, students.size());
    }

    /*
     * Задача.
     * Вы коллекционируете уникальные монеты.
     * У вас имеется специальный бокс с секциями, куда вы складываете монеты в хаотичном порядке.
     *
     * Вопрос.
     * Какую коллекцию из Collections framework вы предпочтете использовать для хранения монет в боксе.
     *
     * Проинициализируйте moneyBox, добавьте в нее 10 монет что бы тест завершился успешно.
     */
    @Test
    public void addMoneyToBox() {
        /*
        * Нам необходимо хранилище данных, в котором важна уникальность значений, но не важен порядок хранения
        * для данной задачи лучше всего использовать HashSet.
        * (при необходимости порядка хранения - LinkedHashSet)
        */
        Set<Integer> moneyBox = new HashSet<Integer>() {{
            add(1); add(2); add(3);add(4);add(5);add(6);add(7);add(8);add(9);add(10);
        }};
        // Возможно ли более коротко записать без использования стримов?

        assertEquals(10, moneyBox.size());
    }

    /*
     * Задача.
     * Имеется книжная полка.
     * Периодически вы берете книгу для чтения, затем кладете ее на свое место.
     *
     * Вопрос.
     * Какую коллекцию из Collections framework вы предпочтете использовать для хранения книг.
     *
     * Проинициализируйте bookshelf, добавьте в нее 3 книги что бы тест завершился успешно.
     */
    @Test
    public void addBookToShelf() {

        /* Из условия поставленной задачи следует:
         * У каждой книги есть своё место.
         * На полке могут быть одинаковые книги.
         * Чтобы взять книгу с полки - нужно найти её место.
         * Самым простым решением данной задачи, будет использование ArrayList, так как
         * время доступа к элементу по индексу минимально - O(1)
         */

        class Book {
        }

        List<Book> bookshelf = Collections.unmodifiableList(new ArrayList<Book>(){{
            add(new Book());
            add(new Book());
            add(new Book());
        }});

        assertEquals(3, bookshelf.size());
    }

    /*
     * Доп. задание
     * Имеется автомат.
     * Время от времени игрок-солдат проивзодит стрельбу из него.
     * Принцип стрельбы из автомата: патрон, который заряжается последним, будет выпущен первым.
     *
     * Вопрос.
     * Какую коллекцию из Collections framework вы предпочтете использовать для хранения патронов в рожке автомата.
     *
     * Проинициализируйте machineGunClip, добавьте в неё 1/6 (5 патронов), что бы тест завершился успешно.
     */
    @Test
    public void addCartridge() {
        /*
        * В контексте данной задачи можно выделить следующее:
        * Добавляются патроны в рожок (обойму) последовательно.
        * Патрон, который зайдёт последним, будет выпущен из автомата первым.
        * Это значит, что структура данных должна выполнять принцип LIFO.
        * В связи с этим, хоть эту структуру и не используют в настоящее время,
        * лучше всего использовать Stack.
         */
        class Patron {

        }

        List<Patron> machineGunClip = new Stack<Patron>(){{
            add(new Patron());
            add(new Patron());
            add(new Patron());
            add(new Patron());
            add(new Patron());
        }};

        assertEquals(5, machineGunClip.size());
    }



}
